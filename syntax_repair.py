#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Codegen for a tiny, pure Python syntax repair toolkit.
- Generates two files inside ./py-syntax-repair/ :
  1) py_syntax_repair_tool.py        (the tool)
  2) test_py_syntax_repair_tool.py   (unit tests, unittest stdlib)
- All functions ≤10 lines, 79 cols, mypy-friendly typing.
- Usage: python generate_py_syntax_repair_tool.py
"""
from __future__ import annotations

from pathlib import Path
from typing import Iterable, List

# ------------------------------- Utilities -------------------------------- #

ROOT = Path("py-syntax-repair")


def _w(path: Path, text: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(text, encoding="utf-8")


def _p(name: str) -> Path:
    return ROOT / name


def _emit(name: str, content: str) -> None:
    _w(_p(name), content)
    print(f"✓ Wrote {ROOT / name}")


def _join(lines: Iterable[str]) -> str:
    return "\n".join(lines) + "\n"


# ----------------------------- File contents ------------------------------ #

tool_py = _join(
    [
        "#!/usr/bin/env python3",
        "# -*- coding: utf-8 -*-",
        '"""',
        "Automatic Python syntax repair tool.",
        "- Scans recursively for .py files.",
        "- Detects SyntaxError via ast.parse.",
        "- Applies heuristic repairs (colons, brackets, quotes, EOF NL).",
        "- Writes .bak and only overwrites if re-parse succeeds.",
        "- Pure tiny functions (≤10 lines), 79 cols, mypy-friendly typing.",
        "- Run: python py_syntax_repair_tool.py --help",
        '"""',
        "from __future__ import annotations",
        "",
        "import argparse",
        "import ast",
        "import os",
        "import re",
        "import sys",
        "from dataclasses import dataclass",
        "from pathlib import Path",
        "from typing import Callable, Iterable, Iterator, List, Optional",
        "from typing import Sequence, Tuple",
        "",
        "# ---------------------------- Data structs ---------------------------- #",
        "",
        "@dataclass(frozen=True)",
        "class RepairResult:",
        "    ok: bool",
        "    code: str",
        "    applied: Tuple[str, ...]",
        "",
        "@dataclass(frozen=True)",
        "class Case:",
        "    name: str",
        "    bad: str",
        "    good: str",
        "",
        "Fixer = Callable[[str], Tuple[str, bool]]",
        "",
        "# ------------------------------- IO ---------------------------------- #",
        "",
        "def read_text(p: Path) -> str:",
        "    return p.read_text(encoding=\"utf-8\", errors=\"surrogatepass\")",
        "",
        "def write_text(p: Path, s: str) -> None:",
        "    p.write_text(s, encoding=\"utf-8\")",
        "",
        "def backup_path(p: Path) -> Path:",
        "    return p.with_suffix(p.suffix + \".bak\")",
        "",
        "def copy_backup(src: Path) -> Path:",
        "    dst = backup_path(src)",
        "    write_text(dst, read_text(src))",
        "    return dst",
        "",
        "# ----------------------------- Small strings -------------------------- #",
        "",
        "def lines(s: str) -> List[str]:",
        "    return s.splitlines()",
        "",
        "def join_lines(xs: Iterable[str]) -> str:",
        "    return \"\\n\".join(xs) + \"\\n\"",
        "",
        "def trailing_newline(s: str) -> str:",
        "    return s if s.endswith(\"\\n\") else s + \"\\n\"",
        "",
        "def rstrip_nl(s: str) -> str:",
        "    return s[:-1] if s.endswith(\"\\n\") else s",
        "",
        "# ----------------------------- Heuristics ----------------------------- #",
        "",
        "KEYWORDS_WITH_COLON = (",
        "    'if','elif','else','for','while','try','except','finally',",
        "    'def','class','with','match','case',",
        ")",
        "",
        "PAIRS = {'(': ')', '[': ']', '{': '}'}",
        "OPENERS = ''.join(PAIRS.keys())",
        "CLOSERS = ''.join(PAIRS.values())",
        "TRIPLE = (\"'''\", '"""')",
        "SINGLE = ("'", '\"")",
        "",
        "def ast_ok(code: str) -> bool:",
        "    try:",
        "        ast.parse(code)",
        "        return True",
        "    except SyntaxError:",
        "        return False",
        "",
        "def add_missing_colons(code: str) -> Tuple[str, bool]:",
        "    out: List[str] = []",
        "    changed = False",
        "    pat = r'^\\s*(%s)\\b.*[^:]$' % '|'.join(KEYWORDS_WITH_COLON)",
        "    for ln in lines(code):",
        "        head = ln.split('#', 1)[0].rstrip()",
        "        if re.match(pat, head):",
        "            ln = ln + ':'",
        "            changed = True",
        "        out.append(ln)",
        "    return join_lines(out), changed",
        "",
        "def _balance_scan(code: str) -> List[str]:",
        "    stk: List[str] = []",
        "    for ch in code:",
        "        if ch in OPENERS:",
        "            stk.append(ch)",
        "        elif ch in CLOSERS and stk:",
        "            if PAIRS.get(stk[-1]) == ch:",
        "                stk.pop()",
        "    return stk",
        "",
        "def balance_brackets(code: str) -> Tuple[str, bool]:",
        "    stk = _balance_scan(code)",
        "    added: List[str] = []",
        "    while stk:",
        "        added.append(PAIRS[stk.pop()])",
        "    return code + ''.join(added), bool(added)",
        "",
        "def close_triple_quotes(code: str) -> Tuple[str, bool]:",
        "    changed = False",
        "    for q in TRIPLE:",
        "        if code.count(q) % 2 == 1:",
        "            code += q",
        "            changed = True",
        "    return code, changed",
        "",
        "def _fix_line_quotes(line: str) -> Tuple[str, bool]:",
        "    changed = False",
        "    head = line.split('#', 1)[0]",
        "    for q in SINGLE:",
        "        if head.count(q) % 2 == 1:",
        "            line += q",
        "            changed = True",
        "    return line, changed",
        "",
        "def close_single_quotes(code: str) -> Tuple[str, bool]:",
        "    out: List[str] = []",
        "    changed = False",
        "    for ln in lines(code):",
        "        ln2, ch = _fix_line_quotes(ln)",
        "        changed = changed or ch",
        "        out.append(ln2)",
        "    return join_lines(out), changed",
        "",
        "def ensure_newline_eof(code: str) -> Tuple[str, bool]:",
        "    s = trailing_newline(code)",
        "    return s, s != code",
        "",
        "def strip_trailing_ws(code: str) -> Tuple[str, bool]:",
        "    out = [rstrip_nl(ln).rstrip() for ln in lines(code)]",
        "    s = join_lines(out)",
        "    return s, s != code",
        "",
        "def fixers() -> Tuple[Fixer, ...]:",
        "    return (",
        "        add_missing_colons,",
        "        close_triple_quotes,",
        "        close_single_quotes,",
        "        balance_brackets,",
        "        ensure_newline_eof,",
        "        strip_trailing_ws,",
        "    )",
        "",
        "def apply_fixes_once(code: str) -> RepairResult:",
        "    applied: List[str] = []",
        "    for fx in fixers():",
        "        code2, changed = fx(code)",
        "        if changed:",
        "            applied.append(fx.__name__)",
        "            code = code2",
        "    return RepairResult(ast_ok(code), code, tuple(applied))",
        "",
        "def repair_code(code: str, limit: int) -> RepairResult:",
        "    step = 0",
        "    applied_all: List[str] = []",
        "    cur = code",
        "    while step < limit:",
        "        res = apply_fixes_once(cur)",
        "        applied_all.extend(res.applied)",
        "        if res.ok or not res.applied:",
        "            return RepairResult(res.ok, res.code, tuple(applied_all))",
        "        cur = res.code",
        "        step += 1",
        "    return RepairResult(False, cur, tuple(applied_all))",
        "",
        "# ------------------------------ Files -------------------------------- #",
        "",
        "def is_py(p: Path) -> bool:",
        "    return p.suffix == '.py'",
        "",
        "def ignore_dirs() -> Tuple[str, ...]:",
        "    return ('.git','__pycache__','.venv','venv','.mypy_cache')",
        "",
        "def walk_py(root: Path) -> Iterator[Path]:",
        "    bad = set(ignore_dirs())",
        "    for dp, dns, fns in os.walk(root):",
        "        dns[:] = [d for d in dns if d not in bad]",
        "        for f in fns:",
        "            p = Path(dp) / f",
        "            if is_py(p):",
        "                yield p",
        "",
        "def needs_repair(p: Path) -> bool:\",
        "    try:",
        "        return not ast_ok(read_text(p))",
        "    except Exception:",
        "        return True",
        "",
        "def repair_file(p: Path, limit: int, dry: bool) -> Tuple[bool,",
        "                                         Tuple[str, ...]]:",
        "    src = read_text(p)",
        "    res = repair_code(src, limit)",
        "    if res.ok and not dry:",
        "        copy_backup(p)",
        "        write_text(p, res.code)",
        "    return res.ok, res.applied",
        "",
        "# ------------------------------- Report ------------------------------- #",
        "",
        "def fmt_result(p: Path, ok: bool, applied: Sequence[str]) -> str:",
        "    tag = 'FIXED' if ok else 'FAILED'",
        "    apps = ','.join(applied) if applied else '-'",
        "    return f\"{tag:6} {p} [{apps}]\"",
        "",
        "def log(msg: str, *, quiet: bool) -> None:",
        "    if not quiet:",
        "        print(msg)",
        "",
        "# --------------------------------- CLI -------------------------------- #",
        "",
        "def add_dir_arg(pa: argparse.ArgumentParser) -> None:",
        "    pa.add_argument('dir', nargs='?', default='.', help='root directory')",
        "",
        "def add_limit_arg(pa: argparse.ArgumentParser) -> None:",
        "    pa.add_argument('--limit', type=int, default=5, help='max passes')",
        "",
        "def add_dry_arg(pa: argparse.ArgumentParser) -> None:",
        "    pa.add_argument('--dry-run', action='store_true', help='no writes')",
        "",
        "def add_quiet_arg(pa: argparse.ArgumentParser) -> None:",
        "    pa.add_argument('-q','--quiet', action='store_true',",
        "                    help='silence')",
        "",
        "def add_selftest_arg(pa: argparse.ArgumentParser) -> None:",
        "    pa.add_argument('--self-test', action='store_true',",
        "                    help='run tests')",
        "",
        "def build_parser() -> argparse.ArgumentParser:",
        "    pa = argparse.ArgumentParser(prog='py-syntax-repair')",
        "    for f in (add_dir_arg, add_limit_arg, add_dry_arg,",
        "              add_quiet_arg, add_selftest_arg):",
        "        f(pa)",
        "    return pa",
        "",
        "# ------------------------------- Selftest ----------------------------- #",
        "",
        "def cases() -> Tuple[Case, ...]:",
        "    return (",
        "        Case('colon_if', 'if True\\n    pass', 'if True:\\n    pass\\n'),",
        "        Case('paren', 'x = (1+2\\n', 'x = (1+2)\\n'),",
        "        Case('triple', \"s = '''abc\\n\", \"s = '''abc'''\\n\"),",
        "        Case('single', \"s = 'a\\n\", \"s = 'a'\\n\"),",
        "        Case('eofnl', 'x=1', 'x=1\\n'),",
        "    )",
        "",
        "def run_case(c: Case) -> Tuple[bool, str]:",
        "    res = repair_code(c.bad, 5)",
        "    ok = res.ok and res.code == c.good",
        "    return ok, c.name",
        "",
        "def run_tests() -> int:",
        "    fails: List[str] = []",
        "    for c in cases():",
        "        ok, name = run_case(c)",
        "        if not ok:",
        "            fails.append(name)",
        "    if fails:",
        "        print('TEST FAIL:', ', '.join(fails))",
        "        return 1",
        "    print('All tests passed.')",
        "    return 0",
        "",
        "# --------------------------------- Main ------------------------------- #",
        "",
        "def main(argv: Optional[Sequence[str]] = None) -> int:",
        "    pa = build_parser()",
        "    ns = pa.parse_args(argv)",
        "    if ns.self_test:",
        "        return run_tests()",
        "    root = Path(ns.dir).resolve()",
        "    any_fail = False",
        "    for p in walk_py(root):",
        "        try:",
        "            need = needs_repair(p)",
        "        except Exception:",
        "            need = True",
        "        if need:",
        "            ok, apps = repair_file(p, ns.limit, ns.dry_run)",
        "            any_fail |= not ok",
        "            log(fmt_result(p, ok, apps), quiet=ns.quiet)",
        "    return 1 if any_fail else 0",
        "",
        "if __name__ == '__main__':",
        "    sys.exit(main())",
    ]
)


tests_py = _join(
    [
        "#!/usr/bin/env python3",
        "# -*- coding: utf-8 -*-",
        '"""',
        "Unit tests for py_syntax_repair_tool.py (unittest).",
        '"""',
        "from __future__ import annotations",
        "",
        "import unittest",
        "from py_syntax_repair_tool import repair_code",
        "",
        "class TestRepair(unittest.TestCase):",
        "    def _ok(self, bad: str, good: str) -> None:",
        "        res = repair_code(bad, 5)",
        "        self.assertTrue(res.ok, res.applied)",
        "        self.assertEqual(res.code, good)",
        "",
        "    def test_colon(self) -> None:",
        "        self._ok('if True\\n    pass', 'if True:\\n    pass\\n')",
        "",
        "    def test_paren(self) -> None:",
        "        self._ok('x=(1+2\\n', 'x=(1+2)\\n')",
        "",
        "    def test_triple(self) -> None:",
        "        self._ok(\"s='''abc\\n\", \"s='''abc'''\\n\")",
        "",
        "    def test_single(self) -> None:",
        "        self._ok(\"s='a\\n\", \"s='a'\\n\")",
        "",
        "    def test_eofnl(self) -> None:",
        "        self._ok('x=1', 'x=1\\n')",
        "",
        "if __name__ == '__main__':",
        "    unittest.main()",
    ]
)


# --------------------------------- Main ---------------------------------- #

def main() -> None:
    _emit("py_syntax_repair_tool.py", tool_py)
    _emit("test_py_syntax_repair_tool.py", tests_py)


if __name__ == "__main__":
    main()
